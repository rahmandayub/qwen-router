require('dotenv').config();
const express = require('express');
const axios = require('axios');
const fs = require('fs');
const { spawn } = require('child_process');
const crypto = require('crypto');

const app = express();

// Konfigurasi via .env
const PORT = process.env.PORT || 4000;
const CREDENTIALS_PATH = process.env.CREDENTIALS_PATH;
const QWEN_CLI_PATH = process.env.QWEN_CLI_PATH || 'qwen';
const CHECK_INTERVAL_MS = process.env.CHECK_INTERVAL_MS || 1800000; // 30 menit
const ROUTER_API_KEY = process.env.ROUTER_API_KEY;
const SSL_KEY_PATH = process.env.SSL_KEY_PATH;
const SSL_CERT_PATH = process.env.SSL_CERT_PATH;
const https = require('https');

// Middleware
// ... (middleware code unchanged)

// Middleware
app.use(express.json());

// Token validation is now handled by the CLI itself, but we can keep the file check
async function checkAuthStatus() {
    try {
        if (!fs.existsSync(CREDENTIALS_PATH)) {
            console.error('âš ï¸ Credentials file not found:', CREDENTIALS_PATH);
            return false;
        }
        return true;
    } catch (error) {
        return false;
    }
}

// Helper to safely extract text content
function extractContent(content) {
    if (typeof content === 'string') return content;
    if (Array.isArray(content)) {
        return content
            .map((part) => {
                if (typeof part === 'string') return part;
                if (part && part.type === 'text') return part.text || '';
                // Skip non-text parts (like images) for now
                return '';
            })
            .join('');
    }
    if (typeof content === 'object' && content !== null) {
        return JSON.stringify(content);
    }
    return String(content || '');
}

// Convert OpenAI tools/functions array into Qwen-compatible tool description block
function formatToolDefinitions(tools, functions) {
    const toolDefs = [];

    // Handle OpenAI "tools" format (preferred)
    if (Array.isArray(tools)) {
        for (const tool of tools) {
            if (tool.type === 'function' && tool.function) {
                toolDefs.push(tool.function);
            }
        }
    }

    // Handle legacy OpenAI "functions" format
    if (Array.isArray(functions)) {
        for (const fn of functions) {
            toolDefs.push(fn);
        }
    }

    if (toolDefs.length === 0) return '';

    // Format as Qwen-style tool definitions (compatible with Qwen2.5+)
    let block =
        '\n\n# Tools\n\nYou may call one or more functions to assist with the user query.\n\n';
    block +=
        'You are provided with function signatures within <tools></tools> XML tags:\n<tools>\n';
    for (const def of toolDefs) {
        block +=
            JSON.stringify({
                type: 'function',
                function: {
                    name: def.name,
                    description: def.description || '',
                    parameters: def.parameters || {},
                },
            }) + '\n';
    }
    block += '</tools>\n\n';
    block +=
        'For each function call, return a json object with function name and arguments within <tool_call></tool_call> XML tags:\n';
    block +=
        '<tool_call>\n{"name": "<function-name>", "arguments": <args-json-object>}\n</tool_call>';
    return block;
}

// Format a single assistant tool_calls array as Qwen ChatML content
function formatAssistantToolCalls(toolCalls) {
    let out = '';
    for (const tc of toolCalls) {
        const fn = tc.function || {};
        const args =
            typeof fn.arguments === 'string'
                ? fn.arguments
                : JSON.stringify(fn.arguments || {});
        out += `\n<tool_call>\n{"name": "${fn.name}", "arguments": ${args}}\n</tool_call>`;
    }
    return out;
}

// Convert OpenAI messages format to a single prompt string
// Now supports tools, functions, tool role, and assistant tool_calls
function formatPrompt(messages, tools, functions) {
    const toolBlock = formatToolDefinitions(tools, functions);
    let prompt = '';

    for (const msg of messages) {
        const content = extractContent(msg.content);

        if (msg.role === 'system') {
            // Inject tool definitions at the end of the system message
            prompt += `<|im_start|>system\n${content}${toolBlock}<|im_end|>\n`;
        } else if (msg.role === 'user') {
            prompt += `<|im_start|>user\n${content}<|im_end|>\n`;
        } else if (msg.role === 'assistant') {
            // If the assistant message contains tool_calls, render them
            if (Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {
                const tcContent =
                    (content || '') + formatAssistantToolCalls(msg.tool_calls);
                prompt += `<|im_start|>assistant\n${tcContent}<|im_end|>\n`;
            } else {
                prompt += `<|im_start|>assistant\n${content}<|im_end|>\n`;
            }
        } else if (msg.role === 'tool') {
            // Tool result message â€” include tool_call_id for context
            const toolCallId = msg.tool_call_id || 'unknown';
            const name = msg.name || '';
            prompt += `<|im_start|>user\n<tool_response>\n{"tool_call_id": "${toolCallId}", "name": "${name}", "content": ${JSON.stringify(content)}}\n</tool_response><|im_end|>\n`;
        } else if (msg.role === 'function') {
            // Legacy function result message
            const name = msg.name || '';
            prompt += `<|im_start|>user\n<tool_response>\n{"name": "${name}", "content": ${JSON.stringify(content)}}\n</tool_response><|im_end|>\n`;
        } else {
            prompt += `\n${msg.role}: ${content}\n`;
        }
    }

    // If no system message was present but tools are defined, prepend one
    if (toolBlock && !messages.some((m) => m.role === 'system')) {
        prompt =
            `<|im_start|>system\nYou are a helpful assistant.${toolBlock}<|im_end|>\n` +
            prompt;
    }

    // Append prompt for assistant to start
    prompt += '<|im_start|>assistant\n';
    return prompt;
}

// Parse tool calls from raw assistant text output
// Detects <tool_call>...</tool_call> blocks and extracts structured calls
function parseToolCalls(text) {
    const toolCalls = [];
    // Match all <tool_call>...</tool_call> blocks
    const regex = /<tool_call>\s*([\s\S]*?)\s*<\/tool_call>/g;
    let match;
    while ((match = regex.exec(text)) !== null) {
        try {
            const parsed = JSON.parse(match[1].trim());
            const name = parsed.name || parsed.function || '';
            const args =
                parsed.arguments || parsed.args || parsed.parameters || {};
            toolCalls.push({
                id: `call_${crypto.randomUUID().replace(/-/g, '').slice(0, 24)}`,
                type: 'function',
                function: {
                    name: name,
                    arguments:
                        typeof args === 'string' ? args : JSON.stringify(args),
                },
            });
        } catch (e) {
            console.log(`[Tool Call Parse Error]: ${e.message}`);
        }
    }

    // Also handle Qwen's older âœ¿FUNCTIONâœ¿/âœ¿ARGSâœ¿ format
    const legacyRegex =
        /âœ¿FUNCTIONâœ¿:\s*(\S+)\s*\nâœ¿ARGSâœ¿:\s*([\s\S]*?)(?=\nâœ¿|$)/g;
    while ((match = legacyRegex.exec(text)) !== null) {
        try {
            const name = match[1].trim();
            const argsStr = match[2].trim();
            const args = JSON.parse(argsStr);
            toolCalls.push({
                id: `call_${crypto.randomUUID().replace(/-/g, '').slice(0, 24)}`,
                type: 'function',
                function: {
                    name: name,
                    arguments:
                        typeof args === 'string' ? args : JSON.stringify(args),
                },
            });
        } catch (e) {
            console.log(`[Legacy Tool Call Parse Error]: ${e.message}`);
        }
    }

    return toolCalls;
}

// Extract plain text content by removing tool_call blocks
function stripToolCalls(text) {
    return text
        .replace(/<tool_call>[\s\S]*?<\/tool_call>/g, '')
        .replace(/âœ¿FUNCTIONâœ¿:[\s\S]*?(?=\nâœ¿|$)/g, '')
        .replace(/âœ¿ARGSâœ¿:[\s\S]*?(?=\nâœ¿|$)/g, '')
        .trim();
}

// Endpoint Health Check
app.get('/health', (req, res) => {
    const status = {
        status: 'online',
        server_time: new Date().toISOString(),
        cli_path: QWEN_CLI_PATH,
        credentials_path: CREDENTIALS_PATH,
    };
    res.json(status);
});

// Endpoint List Models (OpenAI Compatible)
app.get('/v1/models', (req, res) => {
    const models = {
        object: 'list',
        data: [
            {
                id: 'qwen3-coder-plus',
                object: 'model',
                created: 1677610602,
                owned_by: 'qwen',
            },
            {
                id: 'qwen3-coder-flash',
                object: 'model',
                created: 1677610602,
                owned_by: 'qwen',
            },
        ],
    };
    res.json(models);
});

// Handler request chat completion
app.post('/v1/chat/completions', async (req, res) => {
    // 1. API Key Validation
    if (ROUTER_API_KEY) {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];

        if (token !== ROUTER_API_KEY) {
            return res
                .status(401)
                .json({ error: 'Unauthorized: Invalid Router API Key' });
        }
    }

    const {
        messages,
        stream,
        model,
        tools,
        functions,
        tool_choice,
        function_call,
    } = req.body;
    const requestId = crypto.randomUUID();
    const hasTools =
        (Array.isArray(tools) && tools.length > 0) ||
        (Array.isArray(functions) && functions.length > 0);

    console.log(`[${new Date().toLocaleTimeString()}] Request ${requestId}`);
    console.log(`  â†’ Model: ${model}`);
    if (hasTools) {
        console.log(
            `  â†’ Tools: ${(tools || functions).map((t) => t.function?.name || t.name).join(', ')}`,
        );
        if (tool_choice)
            console.log(`  â†’ Tool Choice: ${JSON.stringify(tool_choice)}`);
    }

    const prompt = formatPrompt(messages || [], tools, functions);
    console.log(`  â†’ Input Prompt Length: ${prompt.length} chars`);

    // Setup headers for SSE if streaming
    if (stream) {
        res.setHeader('Content-Type', 'text/event-stream');
        res.setHeader('Cache-Control', 'no-cache');
        res.setHeader('Connection', 'keep-alive');
    } else {
        res.setHeader('Content-Type', 'application/json');
    }

    const controller = new AbortController();

    // Spawn Qwen CLI
    // Usage: qwen -p "PROMPT" --auth-type qwen-oauth --output-format stream-json
    // We use --no-interaction or similar if implied by -p?
    // Based on help: "use -p/--prompt for non-interactive mode"
    const args = [
        '-p',
        prompt,
        '--auth-type',
        'qwen-oauth', // Ensure we use OAuth
        '--output-format',
        'stream-json',
    ];

    if (model) {
        // args.push('--model', model); // Only if user provided model is valid Qwen model ID
        // For safety, let's stick to default or configured model in CLI, or use valid map.
        // But CLI defaults to 'coder-model' which behaves well.
        // Uncomment to pass model: args.push('--model', model);
    }

    console.log(`  â†’ Spawning: ${QWEN_CLI_PATH} ${args.join(' ')}`);

    const child = spawn(QWEN_CLI_PATH, args, {
        signal: controller.signal,
        env: process.env, // Inherit env (PATH, etc)
    });

    let collectedText = '';
    let sentRole = false;

    let buffer = '';

    child.stdout.on('data', (data) => {
        buffer += data.toString();

        let boundary = buffer.indexOf('\n');
        while (boundary !== -1) {
            const line = buffer.substring(0, boundary).trim();
            buffer = buffer.substring(boundary + 1);
            boundary = buffer.indexOf('\n');

            if (!line) continue;

            if (process.env.DEBUG === 'true') {
                console.log(`[CLI RAW]: ${line}`);
            }

            try {
                const json = JSON.parse(line);

                let contentChunk = '';

                if (
                    json.type === 'assistant' &&
                    json.message &&
                    json.message.content
                ) {
                    for (const part of json.message.content) {
                        if (part.type === 'text') {
                            contentChunk += part.text;
                        }
                    }
                } else if (
                    json.type === 'message' &&
                    json.role === 'assistant'
                ) {
                    // Potential alternative format
                    if (typeof json.content === 'string') {
                        contentChunk += json.content;
                    } else if (Array.isArray(json.content)) {
                        for (const part of json.content) {
                            if (part.type === 'text') {
                                contentChunk += part.text;
                            }
                        }
                    }
                }

                if (contentChunk) {
                    collectedText += contentChunk;

                    if (stream) {
                        // In streaming mode with tools, buffer everything and send at the end
                        // because we need to determine if the output is a tool call.
                        // For non-tool requests, stream normally.
                        if (!hasTools) {
                            const chunkData = {
                                id: requestId,
                                object: 'chat.completion.chunk',
                                created: Math.floor(Date.now() / 1000),
                                model: model,
                                choices: [
                                    {
                                        index: 0,
                                        delta: { content: contentChunk },
                                        finish_reason: null,
                                    },
                                ],
                            };
                            res.write(`data: ${JSON.stringify(chunkData)}\n\n`);
                        }
                        // When hasTools is true, we buffer and flush on close
                    }
                }
            } catch (e) {
                console.log(`[Parse Error]: ${e.message} on line: ${line}`);
            }
        }
    });

    child.stderr.on('data', (data) => {
        console.error(`  [CLI STDERR]: ${data}`);
    });

    child.on('close', (code) => {
        console.log(`  â†’ CLI exited with code ${code}`);

        // Detect tool calls in the collected output
        const detectedToolCalls = hasTools ? parseToolCalls(collectedText) : [];
        const hasDetectedToolCalls = detectedToolCalls.length > 0;
        const finishReason = hasDetectedToolCalls ? 'tool_calls' : 'stop';

        if (hasDetectedToolCalls) {
            console.log(
                `  â†’ Detected ${detectedToolCalls.length} tool call(s): ${detectedToolCalls.map((tc) => tc.function.name).join(', ')}`,
            );
        }

        if (stream) {
            if (hasDetectedToolCalls) {
                // Flush buffered tool calls as streaming deltas
                const plainText = stripToolCalls(collectedText);

                // Send role delta first
                const roleChunk = {
                    id: requestId,
                    object: 'chat.completion.chunk',
                    created: Math.floor(Date.now() / 1000),
                    model: model,
                    choices: [
                        {
                            index: 0,
                            delta: {
                                role: 'assistant',
                                content: plainText || null,
                                tool_calls: detectedToolCalls.map((tc, i) => ({
                                    index: i,
                                    id: tc.id,
                                    type: 'function',
                                    function: {
                                        name: tc.function.name,
                                        arguments: tc.function.arguments,
                                    },
                                })),
                            },
                            finish_reason: null,
                        },
                    ],
                };
                res.write(`data: ${JSON.stringify(roleChunk)}\n\n`);

                // Send finish delta
                const finishChunk = {
                    id: requestId,
                    object: 'chat.completion.chunk',
                    created: Math.floor(Date.now() / 1000),
                    model: model,
                    choices: [
                        { index: 0, delta: {}, finish_reason: 'tool_calls' },
                    ],
                };
                res.write(`data: ${JSON.stringify(finishChunk)}\n\n`);
            } else {
                // For non-tool streaming, the content was already streamed chunk by chunk.
                // Just send the finish reason.
                if (hasTools) {
                    // If tools were available but no tool call detected, we buffered content.
                    // Flush it now as a single chunk.
                    const contentChunk = {
                        id: requestId,
                        object: 'chat.completion.chunk',
                        created: Math.floor(Date.now() / 1000),
                        model: model,
                        choices: [
                            {
                                index: 0,
                                delta: {
                                    role: 'assistant',
                                    content: collectedText,
                                },
                                finish_reason: null,
                            },
                        ],
                    };
                    res.write(`data: ${JSON.stringify(contentChunk)}\n\n`);
                }
                const finishChunk = {
                    id: requestId,
                    object: 'chat.completion.chunk',
                    created: Math.floor(Date.now() / 1000),
                    model: model,
                    choices: [{ index: 0, delta: {}, finish_reason: 'stop' }],
                };
                res.write(`data: ${JSON.stringify(finishChunk)}\n\n`);
            }
            res.write(`data: [DONE]\n\n`);
            res.end();
        } else {
            // Non-streaming response
            const message = { role: 'assistant' };

            if (hasDetectedToolCalls) {
                const plainText = stripToolCalls(collectedText);
                message.content = plainText || null;
                message.tool_calls = detectedToolCalls;
            } else {
                message.content = collectedText;
            }

            res.json({
                id: requestId,
                object: 'chat.completion',
                created: Math.floor(Date.now() / 1000),
                model: model,
                choices: [
                    {
                        index: 0,
                        message: message,
                        finish_reason: finishReason,
                    },
                ],
                usage: {
                    prompt_tokens: 0,
                    completion_tokens: 0,
                    total_tokens: 0,
                },
            });
        }
    });

    child.on('error', (err) => {
        console.error('  â†’ Failed to start CLI:', err);
        if (!res.headersSent) {
            res.status(500).json({
                error: 'Failed to spawn Qwen CLI',
                details: err.message,
            });
        }
    });

    // Close stdin to ensure CLI doesn't wait for input
    child.stdin.end();

    // Handle Client Disconnect
    res.on('close', () => {
        if (child && !child.killed && typeof child.kill === 'function') {
            console.log('âš ï¸ Cliet disconnected. Killing CLI process...');
            child.kill();
        }
    });
});

// Menjalankan Server
async function startServer() {
    let server;
    let protocol = 'http';

    if (
        SSL_KEY_PATH &&
        SSL_CERT_PATH &&
        fs.existsSync(SSL_KEY_PATH) &&
        fs.existsSync(SSL_CERT_PATH)
    ) {
        try {
            const options = {
                key: fs.readFileSync(SSL_KEY_PATH),
                cert: fs.readFileSync(SSL_CERT_PATH),
            };
            server = https.createServer(options, app);
            protocol = 'https';
            console.log('ðŸ”’ SSL Certificates loaded successfully.');
        } catch (e) {
            console.error(
                'âš ï¸ Failed to load SSL certificates, falling back to HTTP:',
                e.message,
            );
            server = require('http').createServer(app);
        }
    } else {
        server = require('http').createServer(app);
    }

    server.listen(PORT, async () => {
        console.log(`
  ðŸš€ Qwen Local Router Aktif!
  ---------------------------------------------------
  URL Endpoint : ${protocol}://localhost:${PORT}/v1
  API Key       : ${ROUTER_API_KEY ? '(Protected)' : '(Public/Open)'}
  Model         : qwen3-coder-plus
  API Base      : (CLI Wrapper Mode)
  Default API   : (Managed by CLI)
  File Path     : ${CREDENTIALS_PATH}
  Background Refresh: (Managed by CLI)
  ---------------------------------------------------
  Tekan CTRL+C untuk berhenti.
        `);

        // Cek token saat startup
        await checkAuthStatus();
    });
}

startServer();
